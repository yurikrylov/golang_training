package utils

import (
	"errors"
	"fmt"
)

/*
	Разворот: Напиши функцию, которая принимает срез целых чисел и меняет их порядок на обратный (in-place, без создания нового среза).

    Удаление дубликатов: Дан срез строк. Верни новый срез, содержащий только уникальные значения.

    Слияние: Даны два отсортированных среза. Объедини их в один так, чтобы результат тоже был отсортирован.

    Фильтрация: Напиши функцию, которая удаляет из среза все отрицательные числа.

    Chunking: Разбей большой срез на «пакеты» (слайсы слайсов) заданного размера n.

    Удаление по индексу: Напиши функцию remove(s []int, i int), которая удаляет элемент по индексу, сохраняя порядок.

    Циклический сдвиг: Сдвинь элементы среза вправо на k позиций (например, [1,2,3] при k=1 станет [3,1,2]).

    Поиск пересечения: Найди общие элементы в двух разных срезах.

    Максимальный подмассив: Найди непрерывный подмассив с наибольшей суммой элементов (классическая задача Кадана).

    Безопасное копирование: Создай функцию, которая копирует только первые N элементов из одного среза в другой, учитывая, что исходный срез может быть короче N.
*/

/*
Напишите функцию, которая принимает срез целых чисел и меняет их порядок на обратный (in-place, без создания нового среза).
*/
func GeminiQ1(s []int) {
	for i, j := 0, len(s)-1; i < j; i, j = i+1, j-1 {
		s[i], s[j] = s[j], s[i]
	}
}

func MergeSorted(s1, s2 []int) ([]int, error) {
	if len(s1) == 0 && len(s2) == 0 {
		return nil, errors.New("invalid input")
	}
	result := make([]int, 0, len(s1)+len(s2))
	i, j := 0, 0

	for i < len(s1) && j < len(s2) {
		if s1[i] <= s2[j] {
			result = append(result, s1[i])
			i++
		} else {
			result = append(result, s2[j])
			j++
		}
	}

	result = append(result, s1[i:]...)
	result = append(result, s2[j:]...)

	return result, nil
}

func TestGeminiQ2() {
	a := []int{1, 3, 5}
	b := []int{2, 4, 6}
	merged, err := MergeSorted(a, b)
	if err != nil {
		fmt.Println("Error:", err)
	}
	fmt.Println("Merged slice:", merged)
}
